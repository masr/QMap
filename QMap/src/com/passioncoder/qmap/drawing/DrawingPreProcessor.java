package com.passioncoder.qmap.drawing;

import java.util.HashSet;
import java.util.Set;
import org.jgrapht.Graph;
import com.passioncoder.qmap.algorithm.Path;
import com.passioncoder.qmap.algorithm.Point;

public class DrawingPreProcessor {

	/**
	 * Set the coordinate of the drawing
	 * 
	 * @param graph
	 *            The data structure of the schematic map generated by the
	 *            algorithm
	 */
	public void setDrawingCoordinate(Graph<Point, Path> graph) {
		// the maximal and minimal longitude and latitude of the drawing
		// rectangle
		double maxLatitude = 0;
		double minLatitude = 0;
		double maxLongitude = 0;
		double minLongitude = 0;
		// Get the maximal and minimal longitude and latitude of the drawing
		// rectangle in a very primitive method
		Set<Point> pointList = graph.vertexSet();
		maxLatitude = minLatitude = ((Point) (pointList.toArray()[0]))
				.getLatitude();
		maxLongitude = minLongitude = ((Point) (pointList.toArray()[0]))
				.getLongitude();
		for (Point tempPoint : pointList) {
			if (tempPoint.getLatitude() > maxLatitude) {
				maxLatitude = tempPoint.getLatitude();
			}
			if (tempPoint.getLatitude() < minLatitude) {
				minLatitude = tempPoint.getLatitude();
			}
			if (tempPoint.getLongitude() > maxLongitude) {
				maxLongitude = tempPoint.getLongitude();
			}
			if (tempPoint.getLongitude() < minLongitude) {
				minLongitude = tempPoint.getLongitude();
			}
		}
		// Get the actual size of the drawing rectangle
		double actualXSize = 0;
		double actualYSize = 0;
		if ((maxLongitude - minLongitude) > (maxLatitude - minLatitude)) {
			actualXSize = Drawing.maxActualXSize;
			actualYSize = ((maxLatitude - minLatitude) / (maxLongitude - minLongitude))
					* Drawing.maxActualYSize;
		} else {
			actualYSize = Drawing.maxActualYSize;
			actualXSize = ((maxLongitude - minLongitude) / (maxLatitude - minLatitude))
					* Drawing.maxActualXSize;
		}
		// set the property of the drawing
		Drawing.setActualSize(actualXSize, actualYSize);
		Drawing.setNorthwestLongitudeAndLatitude(minLongitude, maxLatitude);
		Drawing.setSoutheastLongitudeAndLatitude(maxLongitude, minLatitude);
		// convert longitude and latitude of points to coordinates on the
		// drawing
		for (Point tempPoint : pointList) {
			coordinateConvertor(tempPoint);
		}
		setPathPosition(graph);
		//setDumplicatePathNewPosition(graph);
	}

	/**
	 * Set the position of one path
	 * 
	 * @param graph
	 *            The data structure of the schematic map generate by the
	 *            algorithm
	 */
	private void setPathPosition(Graph<Point, Path> graph) {
		// TODO Auto-generated method stub
		Set<Path> pathSet = graph.edgeSet();
		for (Path tempPath : pathSet) {
			// List<Point> pointlist=temppath.getPoints();
			tempPath.setPoint1XPosition(graph.getEdgeSource(tempPath)
					.getXPosition());
			tempPath.setPoint1YPosition(graph.getEdgeSource(tempPath)
					.getYPosition());
			tempPath.setPoint2XPosition(graph.getEdgeTarget(tempPath)
					.getXPosition());
			tempPath.setPoint2YPosition(graph.getEdgeTarget(tempPath)
					.getYPosition());
			System.out.println(graph.getEdgeSource(tempPath).getXPosition()
					+ " " + graph.getEdgeSource(tempPath).getYPosition() + " "
					+ tempPath.getPoint1XPosition() + " "
					+ tempPath.getPoint1YPosition());
		}

	}

	/**
	 * Convert the latitude and longitude of the point to the actual X and Y
	 * position in the generated schematic map
	 * 
	 * @param point
	 *            The point of which the position needs to be converted
	 */
	private void coordinateConvertor(Point point) {
		// get the position of the point in the actual drawing
		double xPosition = ((point.getLongitude() - Drawing.northwestLongitude) / (Drawing.southeastLongitude - Drawing.northwestLongitude))
				* Drawing.actualXSize;
		double yPosition = ((Drawing.northwestLatitude - point.getLatitude()) / (Drawing.northwestLatitude - Drawing.southeastLatitude))
				* Drawing.actualYSize;
		// set the position of points
		point.setPosition(xPosition, yPosition);
	}

	/**
	 * Get the direction of one specific path
	 * 
	 * @param graph
	 *            The data structure of the schematic map generated by the
	 *            algorithm
	 * @param path
	 *            The path of which we want to get the direction
	 * @return An integer which represents the direction of the specific path
	 */
	private int getPathDirection(Graph<Point, Path> graph, Path path) {
		Point point1 = graph.getEdgeSource(path);
		Point point2 = graph.getEdgeTarget(path);
		if (point1.getXPosition() - point2.getXPosition() > -5
				&& point1.getXPosition() - point2.getXPosition() < 5) {
			// vertical
			return 1;
		} else if (point1.getYPosition() - point2.getYPosition() > -5
				&& point1.getYPosition() - point2.getYPosition() < 5) {
			// horizonal
			return 2;
		} else if ((point2.getYPosition() - point1.getYPosition())
				/ (point2.getXPosition() - point1.getXPosition()) > 0) {
			// zheng xiang
			return 3;
		} else if ((point2.getYPosition() - point1.getYPosition())
				/ (point2.getXPosition() - point1.getXPosition()) < 0) {
			// fan xiang
			return 4;
		} else {
			return 0;
		}
	}

	/**
	 * Set new positions of duplicate paths
	 * 
	 * @param graph
	 *            The data structure of the schematic map generated by the
	 *            algorithm
	 */
	private void setDumplicatePathNewPosition(Graph<Point, Path> graph) {
		Set<Set<Path>> dumplicatePathSet = findDumplicatePath(graph);
		double offset = 2;
		for (Set<Path> pathSet : dumplicatePathSet) {
			Object[] pathArray = pathSet.toArray();
			assert (pathArray.length == 2);
			switch (getPathDirection(graph, (Path) pathArray[0])) {
			case 1:
				((Path) pathArray[0]).setPoint1XPosition(((Path) pathArray[0])
						.getPoint1XPosition() + offset);
				((Path) pathArray[0]).setPoint2XPosition(((Path) pathArray[0])
						.getPoint2XPosition() + offset);
				((Path) pathArray[1]).setPoint1XPosition(((Path) pathArray[1])
						.getPoint1XPosition() - offset);
				((Path) pathArray[1]).setPoint2XPosition(((Path) pathArray[1])
						.getPoint2XPosition() - offset);
				break;
			case 2:
				((Path) pathArray[0]).setPoint1YPosition(((Path) pathArray[0])
						.getPoint1YPosition() + offset);
				((Path) pathArray[0]).setPoint2YPosition(((Path) pathArray[0])
						.getPoint2YPosition() + offset);
				((Path) pathArray[1]).setPoint1YPosition(((Path) pathArray[1])
						.getPoint1YPosition() - offset);
				((Path) pathArray[1]).setPoint2YPosition(((Path) pathArray[1])
						.getPoint2YPosition() - offset);
				break;
			case 3:
				((Path) pathArray[0]).setPoint1XPosition(((Path) pathArray[0])
						.getPoint1XPosition() + offset);
				((Path) pathArray[0]).setPoint1YPosition(((Path) pathArray[0])
						.getPoint1YPosition() - offset);
				((Path) pathArray[0]).setPoint2XPosition(((Path) pathArray[0])
						.getPoint2XPosition() + offset);
				((Path) pathArray[0]).setPoint2YPosition(((Path) pathArray[0])
						.getPoint2YPosition() - offset);
				((Path) pathArray[1]).setPoint1XPosition(((Path) pathArray[1])
						.getPoint1XPosition() - offset);
				((Path) pathArray[1]).setPoint1YPosition(((Path) pathArray[1])
						.getPoint1YPosition() + offset);
				((Path) pathArray[1]).setPoint2XPosition(((Path) pathArray[1])
						.getPoint2XPosition() - offset);
				((Path) pathArray[1]).setPoint2YPosition(((Path) pathArray[1])
						.getPoint2YPosition() + offset);
				break;
			case 4:
				((Path) pathArray[0]).setPoint1XPosition(((Path) pathArray[0])
						.getPoint1XPosition() + offset);
				((Path) pathArray[0]).setPoint1YPosition(((Path) pathArray[0])
						.getPoint1YPosition() + offset);
				((Path) pathArray[0]).setPoint2XPosition(((Path) pathArray[0])
						.getPoint2XPosition() + offset);
				((Path) pathArray[0]).setPoint2YPosition(((Path) pathArray[0])
						.getPoint2YPosition() + offset);
				((Path) pathArray[1]).setPoint1XPosition(((Path) pathArray[1])
						.getPoint1XPosition() - offset);
				((Path) pathArray[1]).setPoint1YPosition(((Path) pathArray[1])
						.getPoint1YPosition() - offset);
				((Path) pathArray[1]).setPoint2XPosition(((Path) pathArray[1])
						.getPoint2XPosition() - offset);
				((Path) pathArray[1]).setPoint2YPosition(((Path) pathArray[1])
						.getPoint2YPosition() - offset);
				break;
			}
		}
	}

	/**
	 * Find duplicate paths in the graph
	 * 
	 * @param graph
	 *            The data structure of the schematic map generated by the
	 *            algorithm
	 * @return The set of set of duplicated paths
	 */
	private Set<Set<Path>> findDumplicatePath(Graph<Point, Path> graph) {
		Set<Set<Path>> dumplicatePathSet = new HashSet<Set<Path>>();
		Object[] pathArray = graph.edgeSet().toArray();
		for (int index1 = 0; index1 < pathArray.length - 1; index1++) {
			for (int index2 = index1 + 1; index2 < pathArray.length; index2++) {
				if (isDumplicate(graph, (Path) pathArray[index1],
						(Path) pathArray[index2])) {
					Set<Path> tempSet = new HashSet<Path>();
					tempSet.add((Path) pathArray[index1]);
					tempSet.add((Path) pathArray[index2]);
					dumplicatePathSet.add(tempSet);
				}
			}
		}
		return dumplicatePathSet;
	}

	/**
	 * Check if the two paths in the graph are duplicate
	 * 
	 * @param graph
	 *            The data structure of the schematic map generated by the
	 *            algorithm
	 * @param path1
	 *            The first path we want to check
	 * @param path2
	 *            The second path we want to check
	 * @return The boolean value represent whether the two paths are duplicate
	 */
	private boolean isDumplicate(Graph<Point, Path> graph, Path path1,
			Path path2) {
		Point point1OfPath1 = graph.getEdgeTarget(path1);
		Point point2OfPath1 = graph.getEdgeSource(path1);
		Point point1OfPath2 = graph.getEdgeTarget(path2);
		Point point2OfPath2 = graph.getEdgeSource(path2);
		double slopeOfPath1 = (point1OfPath1.getYPosition() - point2OfPath1
				.getYPosition())
				/ ((point1OfPath1.getXPosition() - point2OfPath1.getXPosition()));
		double slopeOfPath2 = (point1OfPath2.getYPosition() - point2OfPath2
				.getYPosition())
				/ ((point1OfPath2.getXPosition() - point2OfPath2.getXPosition()));
		double deviation = 0.01d;
		if (Math.abs(slopeOfPath1 - slopeOfPath2) < deviation) {
			if (Math.abs(getIntercept(point1OfPath1, point2OfPath1)
					- getIntercept(point1OfPath2, point2OfPath2)) < 2 * deviation) {
				// if the two lines coincide
				if (isCoincide(point1OfPath1, point2OfPath1, point1OfPath2,
						point2OfPath2, false)) {
					return true;
				}
			}
		}
		if (Math.abs(slopeOfPath1) > 1000
				&& Math.abs(slopeOfPath2) > 1000
				&& Math.abs(point1OfPath1.getXPosition()
						- point1OfPath2.getXPosition()) < 0.1) {
			// if the two lines coincide
			if (isCoincide(point1OfPath1, point2OfPath1, point1OfPath2,
					point2OfPath2, true)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Get the intercept of one path
	 * 
	 * @param point1
	 *            The first endpoint of the path
	 * @param point2
	 *            The second endpoint of the path
	 * @return The intercept of the path
	 */
	private double getIntercept(Point point1, Point point2) {
		double deltaY = point2.getYPosition() - point1.getYPosition();
		double deltaX = point2.getXPosition() - point1.getXPosition();
		if (Math.abs(deltaX) < 0.01d) {
			return point1.getYPosition();
		} else {
			return point2.getYPosition() - (deltaY / deltaX)
					* point2.getXPosition();
		}
	}

	/**
	 * Check whether the two lines coincide
	 * 
	 * @param point1OfPath1
	 *            The first point of the first path
	 * @param point2OfPath1
	 *            The second point of the first path
	 * @param point1OfPath2
	 *            The first point of the second path
	 * @param point2OfPath2
	 *            The second point of the second path
	 * @param beVertical
	 *            Whether the two paths are vertical which means that the two
	 *            paths do not have a computable intercept
	 * @return The boolean represents whether the two paths coincide
	 */
	private boolean isCoincide(Point point1OfPath1, Point point2OfPath1,
			Point point1OfPath2, Point point2OfPath2, boolean beVertical) {
		if (beVertical) {
			double maxYPositionOfPath2 = point1OfPath2.getYPosition() > point2OfPath2
					.getYPosition() ? point1OfPath2.getYPosition()
					: point2OfPath2.getYPosition();
			double minYPositionOfPath2 = point1OfPath2.getYPosition()
					+ point2OfPath2.getYPosition() - maxYPositionOfPath2;
			double maxYPositionOfPath1 = point1OfPath1.getYPosition() > point2OfPath1
					.getYPosition() ? point1OfPath1.getYPosition()
					: point2OfPath1.getYPosition();
			double minYPositionOfPath1 = point1OfPath1.getYPosition()
					+ point2OfPath1.getYPosition() - maxYPositionOfPath1;
			double actualLength = Math.max(maxYPositionOfPath1,
					maxYPositionOfPath2)
					- Math.min(minYPositionOfPath1, minYPositionOfPath2);
			double length = maxYPositionOfPath1 - minYPositionOfPath1
					+ maxYPositionOfPath2 - minYPositionOfPath2;
			if (length > actualLength
					&& Math.abs(length - actualLength) > 0.01d) {
				System.out.println("这是重合的路 " + point1OfPath1.getName() + "---"
						+ point2OfPath1.getName() + "    "
						+ point1OfPath2.getName() + "---"
						+ point2OfPath2.getName());
				return true;
			} else {
				return false;
			}
		} else {
			double maxXPositionofPath2 = point1OfPath2.getXPosition() > point2OfPath2
					.getXPosition() ? point1OfPath2.getXPosition()
					: point2OfPath2.getXPosition();
			double minXPositionOfPath2 = point1OfPath2.getXPosition()
					+ point2OfPath2.getXPosition() - maxXPositionofPath2;
			double maxXPositionOfPath1 = point1OfPath1.getXPosition() > point2OfPath1
					.getXPosition() ? point1OfPath1.getXPosition()
					: point2OfPath1.getXPosition();
			double minXPositionOfPath1 = point1OfPath1.getXPosition()
					+ point2OfPath1.getXPosition() - maxXPositionOfPath1;
			double actualLength = Math.max(maxXPositionOfPath1,
					maxXPositionofPath2)
					- Math.min(minXPositionOfPath1, minXPositionOfPath2);
			double length = maxXPositionOfPath1 - minXPositionOfPath1
					+ maxXPositionofPath2 - minXPositionOfPath2;
			if (length > actualLength
					&& Math.abs(length - actualLength) > 0.01d) {
				System.out.println("这是重合的路 " + point1OfPath1.getName() + "---"
						+ point2OfPath1.getName() + "    "
						+ point1OfPath2.getName() + "---"
						+ point2OfPath2.getName());
				return true;
			} else {
				return false;
			}
		}
	}

}
